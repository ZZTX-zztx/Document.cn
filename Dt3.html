<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>3D太空射击</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: Arial; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; font-size: 16px; }
        #score { position: absolute; top: 40px; left: 20px; font-size: 18px; }
    </style>
</head>
<body>
    <div id="info">WASD移动 | 鼠标控制瞄准 | 空格射击 | 躲避红色敌机</div>
    <div id="score">得分: 0</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        // 1. 初始化WebGL
        const canvas = document.getElementById('gameCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);

        // 2. Shader程序（顶点+片段）
        const vsSource = `
            attribute vec3 aPosition;
            attribute vec3 aColor;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            varying vec3 vColor;
            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                vColor = aColor;
            }
        `;

        const fsSource = `
            precision mediump float;
            varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

        // 编译Shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // 3. 核心变量
        const programInfo = {
            program,
            attribLocations: { position: gl.getAttribLocation(program, 'aPosition'), color: gl.getAttribLocation(program, 'aColor') },
            uniformLocations: { modelViewMatrix: gl.getUniformLocation(program, 'uModelViewMatrix'), projectionMatrix: gl.getUniformLocation(program, 'uProjectionMatrix') }
        };

        let score = 0;
        const keys = {};
        const player = { x: 0, y: 0, z: -5, size: 0.3, speed: 0.05 };
        const bullets = [];
        const enemies = [];
        const cubeVertices = new Float32Array([
            // 前
            -0.5, -0.5, 0.5, 1,0,0,  0.5, -0.5, 0.5, 1,0,0,  0.5, 0.5, 0.5, 1,0,0,  -0.5, 0.5, 0.5, 1,0,0,
            // 后
            -0.5, -0.5, -0.5, 0,1,0,  -0.5, 0.5, -0.5, 0,1,0,  0.5, 0.5, -0.5, 0,1,0,  0.5, -0.5, -0.5, 0,1,0,
        ]);
        const cubeIndices = new Uint16Array([0,1,2, 0,2,3, 4,5,6, 4,6,7]);

        // 4. 创建缓冲区
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

        // 5. 矩阵工具（简化版）
        const mat4 = {
            perspective: (fov, aspect, near, far) => {
                const f = Math.tan(Math.PI * 0.5 - 0.5 * fov);
                return new Float32Array([
                    f/aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (far+near)/(near-far), -1,
                    0, 0, (2*far*near)/(near-far), 0
                ]);
            },
            lookAt: (eye, center, up) => {
                const z = [eye[0]-center[0], eye[1]-center[1], eye[2]-center[2]];
                const zLen = Math.hypot(...z);
                const zNorm = [z[0]/zLen, z[1]/zLen, z[2]/zLen];
                const x = [up[1]*zNorm[2]-up[2]*zNorm[1], up[2]*zNorm[0]-up[0]*zNorm[2], up[0]*zNorm[1]-up[1]*zNorm[0]];
                const xLen = Math.hypot(...x);
                const xNorm = [x[0]/xLen, x[1]/xLen, x[2]/xLen];
                const y = [zNorm[1]*xNorm[2]-zNorm[2]*xNorm[1], zNorm[2]*xNorm[0]-zNorm[0]*xNorm[2], zNorm[0]*xNorm[1]-zNorm[1]*xNorm[0]];
                return new Float32Array([
                    xNorm[0], y[0], zNorm[0], 0,
                    xNorm[1], y[1], zNorm[1], 0,
                    xNorm[2], y[2], zNorm[2], 0,
                    -xNorm[0]*eye[0]-xNorm[1]*eye[1]-xNorm[2]*eye[2],
                    -y[0]*eye[0]-y[1]*eye[1]-y[2]*eye[2],
                    -zNorm[0]*eye[0]-zNorm[1]*eye[1]-zNorm[2]*eye[2],
                    1
                ]);
            },
            translate: (mat, x, y, z) => {
                const out = [...mat];
                out[12] += mat[0]*x + mat[4]*y + mat[8]*z;
                out[13] += mat[1]*x + mat[5]*y + mat[9]*z;
                out[14] += mat[2]*x + mat[6]*y + mat[10]*z;
                return new Float32Array(out);
            }
        };

        // 6. 游戏逻辑
        function spawnEnemy() {
            enemies.push({
                x: (Math.random()-0.5)*10,
                y: (Math.random()-0.5)*10,
                z: Math.random()*5 + 10,
                size: 0.4,
                speed: 0.03
            });
        }

        function shootBullet() {
            bullets.push({
                x: player.x,
                y: player.y,
                z: player.z + 1,
                speed: 0.2
            });
        }

        function checkCollisions() {
            // 子弹撞敌人
            for (let i = bullets.length-1; i >=0; i--) {
                for (let j = enemies.length-1; j >=0; j--) {
                    const dx = bullets[i].x - enemies[j].x;
                    const dy = bullets[i].y - enemies[j].y;
                    const dz = bullets[i].z - enemies[j].z;
                    if (Math.hypot(dx, dy, dz) < 0.5) {
                        bullets.splice(i,1);
                        enemies.splice(j,1);
                        score += 10;
                        document.getElementById('score').textContent = `得分: ${score}`;
                    }
                }
            }
            // 敌人撞玩家
            enemies.forEach(enemy => {
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const dz = player.z - enemy.z;
                if (Math.hypot(dx, dy, dz) < 0.8) {
                    alert(`游戏结束！最终得分: ${score}`);
                    location.reload();
                }
            });
        }

        // 7. 渲染函数
        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            // 投影矩阵
            const projectionMatrix = mat4.perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 100);
            gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);

            // 玩家（青色）
            const playerMat = mat4.translate(mat4.lookAt([player.x, player.y, player.z], [0,0,0], [0,1,0]), player.x, player.y, player.z);
            gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, playerMat);
            gl.vertexAttribPointer(programInfo.attribLocations.position, 3, gl.FLOAT, false, 24, 0);
            gl.vertexAttribPointer(programInfo.attribLocations.color, 3, gl.FLOAT, false, 24, 12);
            gl.enableVertexAttribArray(programInfo.attribLocations.position);
            gl.enableVertexAttribArray(programInfo.attribLocations.color);
            gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);

            // 子弹（黄色）
            bullets.forEach(bullet => {
                bullet.z += bullet.speed;
                const bulletMat = mat4.translate(mat4.lookAt([bullet.x, bullet.y, bullet.z], [0,0,0], [0,1,0]), bullet.x, bullet.y, bullet.z);
                gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, bulletMat);
                gl.vertexAttribPointer(programInfo.attribLocations.color, 3, gl.FLOAT, false, 24, 12); // 复用顶点，仅改颜色
                gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);
            });

            // 敌人（红色）
            enemies.forEach(enemy => {
                enemy.z -= enemy.speed;
                const enemyMat = mat4.translate(mat4.lookAt([enemy.x, enemy.y, enemy.z], [0,0,0], [0,1,0]), enemy.x, enemy.y, enemy.z);
                gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, enemyMat);
                gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);
            });

            // 清理超出屏幕的子弹
            bullets.forEach((b, i) => b.z > 20 && bullets.splice(i,1));

            // 碰撞检测与敌人生成
            checkCollisions();
            Math.random() < 0.02 && spawnEnemy();

            requestAnimationFrame(render);
        }

        // 8. 控制事件
        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            e.code === 'Space' && shootBullet();
        });
        document.addEventListener('keyup', e => keys[e.code] = false);

        // 玩家移动
        setInterval(() => {
            if (keys['KeyW']) player.z += player.speed;
            if (keys['KeyS']) player.z -= player.speed;
            if (keys['KeyA']) player.x -= player.speed;
            if (keys['KeyD']) player.x += player.speed;
        }, 16);

        // 鼠标瞄准（简化版）
        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', e => {
            mouseX = (e.clientX / canvas.width - 0.5) * 10;
            mouseY = (0.5 - e.clientY / canvas.height) * 10;
            player.x = mouseX * 0.3;
            player.y = mouseY * 0.3;
        });

        // 启动游戏
        render();
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        });
    </script>
</body>
</html>
